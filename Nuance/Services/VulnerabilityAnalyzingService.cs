using NuGet.Common;
using NuGet.Configuration;
using NuGet.Credentials;
using NuGet.Frameworks;
using NuGet.Packaging;
using NuGet.Packaging.Core;
using NuGet.Protocol.Core.Types;
using NuGet.Versioning;


namespace Nuance
{
    public class VulnerabilityAnalyzingService
    {
        public static void Initialize()
        {
            try
            {
                // .NET JIT compiles one method at a time. If this method calls `MSBuildLocator` directly, the
                // try block is never entered if Microsoft.Build.Locator.dll can't be found. So, run it in a
                // lambda function to ensure we're in the try block. C# IIFE!
                ((Action)(() => Microsoft.Build.Locator.MSBuildLocator.RegisterDefaults()))();
            }
            catch
            {
                // MSBuildLocator is used only to enable Visual Studio debugging.
                // It's not needed when using a patched dotnet sdk, so it doesn't matter if it fails.
            }

            DefaultCredentialServiceUtility.SetupDefaultCredentialService(NullLogger.Instance, true);
        }

        public static async Task<VulnerabilityAnalysisResult> GetVulnerabilityAnalysis(string pathToSolution)
        {
            var runner = new ListPackageCommandRunner();

            var settings = Settings.LoadDefaultSettings(pathToSolution);

            var packageSources = GetPackageSources(settings);

            var packageRefArgs = new ListPackageArgs(
                           pathToSolution,
                           packageSources,
                           true,
                           true,
                           false,
                           false,
                           NullLogger.Instance,
                           CancellationToken.None);

            var model = await runner.ExecuteCommandAsync(packageRefArgs);

            var packageReferencePerName = new Dictionary<string, InstalledPackageReference>();

            foreach (var package in model.Projects.SelectMany(p => p.TargetFrameworkPackages.SelectMany(p => p.TopLevelPackages.Union(p.TransitivePackages))))
            {
                packageReferencePerName.TryAdd(package.Name, package);
            }

            var vulnerableDependencies = model.Projects.SelectMany(p => p.TargetFrameworkPackages.SelectMany(p => p.TopLevelPackages.Union(p.TransitivePackages)), (project, package) => new { Project = project, Package = package })
                .Where(p => p.Package.ResolvedPackageMetadata.Vulnerabilities != null)
                .GroupBy(r => new { PackageName = r.Package.Name, r.Package.ResolvedPackageMetadata.Identity?.Version });

            var vulnerablePackages = new List<RealVulnerablePackageInfo>();
            var topLevelPackagesInfo = new Dictionary<string, TopLevelDependencyWithVulnerabilitiesInfo>();
            foreach (var dep in vulnerableDependencies.OrderBy(d => d.Key.PackageName).ThenBy(d => d.Key.Version))
            {
                var vulnerablePackage = dep.First().Package.ResolvedPackageMetadata;
                var targetFramework = dep.First().Project.TargetFrameworkPackages.First().Framework; // TODO: find a better way
                var vulnerablePackageInfo = CreateVulnerablePackageInfo(dep.Key.PackageName, dep.Key.Version, vulnerablePackage, dep.Select(d => d.Package));
                vulnerablePackageInfo.TargetFramework = targetFramework;
                vulnerablePackages.Add(vulnerablePackageInfo);

                foreach (var project in vulnerablePackageInfo.InterestingDependencyPaths) {
                    // 1st element is always a project, so we go deeper
                    foreach (var topDep in project.Children) {
                        topLevelPackagesInfo.TryGetValue(topDep.Id, out TopLevelDependencyWithVulnerabilitiesInfo? topDepInfo);
                        if (topDepInfo == null) {
                            topDepInfo = new TopLevelDependencyWithVulnerabilitiesInfo(topDep) { TargetFramework = targetFramework };
                            topLevelPackagesInfo.Add(topDep.Id, topDepInfo);
                        }
                        if (!topDepInfo.RelatedVulnerabilities.Any(v => v.PackageName == vulnerablePackageInfo.PackageName && v.PackageVersion == vulnerablePackageInfo.PackageVersion))
                            topDepInfo.RelatedVulnerabilities.Add(new VulnerablePackageInfo() { 
                                PackageName = vulnerablePackageInfo.PackageName,
                                PackageVersion = vulnerablePackageInfo.PackageVersion,
                                Vulnerabilities = vulnerablePackageInfo.Vulnerabilities
                            });
                    }
                }
            }

            List<TopLevelDependencyWithVulnerabilitiesInfo> topLevelDependenciesWithVulnerabilities = [.. topLevelPackagesInfo.Values];
            foreach (var vi in topLevelDependenciesWithVulnerabilities)
            {
                var targetFramework = NuGetFramework.Parse(vi.TargetFramework);
                var rootDepNode = vi.Node;
                // let's find the version newer than current with the minimum number of vulnerabilities
                var rootPackageInfo = packageReferencePerName[rootDepNode.Id];
                var leastVulnlerableVersion = GetLeastVulnlerableVersion(rootPackageInfo, packageReferencePerName, targetFramework);
                if (leastVulnlerableVersion.Package.Identity.Version > rootDepNode.Version)
                {
                    vi.BestUpdateCandidate = leastVulnlerableVersion.Package;
                    vi.BestUpdateCandidateRelatedVulnerabilities.AddRange(leastVulnlerableVersion.Vulnerabilities);
                    // below the analysis of which vulnerabilities are solved, which are not and which are new
                    FillInNewAndSolvedVulnerabilities(vi);
                }
                if (leastVulnlerableVersion.Vulnerabilities.Length > 0)
                {
                    // we still have some vulnerabilities in the version
                    // it doesn't matter here if it is new version or our existing installed version
                    // we need to investigate it deeper
                    var dependencySet = GetBestDependencySet(leastVulnlerableVersion.Package, targetFramework);
                    foreach (var childDependency in dependencySet.Packages)
                    {
                        ProcessDependencyWithVulnerabilities(vi, childDependency, packageReferencePerName, targetFramework);
                    }
                }
            }

            return new VulnerabilityAnalysisResult
            {
                VulnerablePackages = vulnerablePackages,
                TopLevelDependencyWithVulnerabilitiesInfo = [.. topLevelPackagesInfo.Values]
            };
        }

        private static void ProcessDependencyWithVulnerabilities(TopLevelDependencyWithVulnerabilitiesInfo parentVulInfo, PackageDependency dependency, Dictionary<string, InstalledPackageReference> packageReferencePerName, NuGetFramework targetFramework)
        {
            packageReferencePerName.TryGetValue(dependency.Id, out var childPackageInfo);
            if (childPackageInfo == null)
                return; // TODO!!!
            var childPackageMetadata = GetChildPackageMetadata(dependency, childPackageInfo);
            if (childPackageMetadata == null)
                return; // TODO!!!
            var childVulnerabilities = GetVulnerabilitiesForPath(childPackageMetadata, packageReferencePerName, targetFramework);

            if (childVulnerabilities.Length > 0)
            {
                var filteredChildVulnerabilities = FilterChildVulnerabilities(parentVulInfo, childVulnerabilities);
                if (filteredChildVulnerabilities.Count > 0)
                {
                    var childVulInfo = new TopLevelDependencyWithVulnerabilitiesInfo(dependency)
                    {
                        TargetFramework = targetFramework.ToString()
                    };

                    childVulInfo.RelatedVulnerabilities.AddRange(filteredChildVulnerabilities.Distinct());
                    parentVulInfo.ChildVulnerabilities.Add(childVulInfo);

                    var leastVulnerableChildVersion = GetLeastVulnlerableVersion(childPackageInfo, packageReferencePerName, targetFramework);

                    if (leastVulnerableChildVersion.Package.Identity.Version > childPackageMetadata.Identity.Version &&
                        leastVulnerableChildVersion.Vulnerabilities.Sum(v => v.Vulnerabilities.Length) <
                        childVulnerabilities.Sum(v => v.Vulnerabilities.Length))
                    {
                        childVulInfo.BestUpdateCandidate = leastVulnerableChildVersion.Package;
                        childVulInfo.BestUpdateCandidateRelatedVulnerabilities.AddRange(leastVulnerableChildVersion.Vulnerabilities);
                        FillInNewAndSolvedVulnerabilities(childVulInfo);
                    }

                    if (leastVulnerableChildVersion.Vulnerabilities.Length > 0)
                    {
                        var dependencySet = GetBestDependencySet(leastVulnerableChildVersion.Package, targetFramework);
                        foreach (var childDependency in dependencySet.Packages)
                        {
                            ProcessDependencyWithVulnerabilities(childVulInfo, childDependency, packageReferencePerName, targetFramework);
                        }
                    }
                }
            }
        }

        private static IPackageSearchMetadata? GetChildPackageMetadata(PackageDependency? childDependency, InstalledPackageReference childPackageInfo)
        {
            return childPackageInfo.AllPackageMetadata.Where(m => m.Identity.Version == childDependency.VersionRange.MinVersion).FirstOrDefault() ??
                childPackageInfo.AllPackageMetadata.Where(m => m.Identity.Version > childDependency.VersionRange.MinVersion).OrderBy(m => m.Identity.Version).FirstOrDefault();
        }

        private static List<VulnerablePackageInfo> FilterChildVulnerabilities(TopLevelDependencyWithVulnerabilitiesInfo root, VulnerablePackageInfo[] childVulnerabilities)
        {
            var filteredChildVulnerabilities = new List<VulnerablePackageInfo>();
            foreach (var childVul in childVulnerabilities)
                if (root.BestUpdateCandidate != null && (root.BestUpdateCandidateNewVulnerabilities.Any(v => v.PackageName == childVul.PackageName && v.PackageVersion == childVul.PackageVersion) ||
                    root.BestUpdateCandidateNotSolvedVulnerabilities.Any(v => v.PackageName == childVul.PackageName && v.PackageVersion == childVul.PackageVersion)) ||
                    root.RelatedVulnerabilities.Any(v => v.PackageName == childVul.PackageName && v.PackageVersion == childVul.PackageVersion))
                    filteredChildVulnerabilities.Add(childVul);
            return filteredChildVulnerabilities;
        }

        private static (IPackageSearchMetadata Package, VulnerablePackageInfo[] Vulnerabilities) GetLeastVulnlerableVersion(InstalledPackageReference rootPackageInfo, Dictionary<string, InstalledPackageReference> packageReferencePerName, NuGetFramework targetFramework)
        {
            return rootPackageInfo.AllPackageMetadata.OrderByDescending(m => m.Identity.Version)
                                        .Where(m => m.Identity.Version >= rootPackageInfo.ResolvedPackageMetadata.Identity.Version)
                                        .Select(v => (v, GetVulnerabilitiesForPath(v, packageReferencePerName, targetFramework)))
                                        .Where(t => t.Item2!=null)
                                        .OrderBy(t => t.Item2.Sum(v => v.Vulnerabilities.Length)).ThenByDescending(t => t.Item1.Identity.Version).FirstOrDefault();
        }

        private static void FillInNewAndSolvedVulnerabilities(TopLevelDependencyWithVulnerabilitiesInfo vi)
        {
            var initialVulnerabilities = new Dictionary<(string, Uri), VulnerablePackageInfo>();
            foreach (var realVul in vi.RelatedVulnerabilities)
            {
                foreach (var advUri in realVul.Vulnerabilities.Select(m => m.AdvisoryUrl))
                {
                    initialVulnerabilities.TryAdd((realVul.PackageName, advUri), realVul);
                }
            }

            if (vi.BestUpdateCandidateRelatedVulnerabilities.Count == 0)
            {
                vi.BestUpdateCandidateSolvedVulnerabilities = vi.RelatedVulnerabilities;
            }
            else
            {
                var notSolvedVulnerabilities = new HashSet<VulnerablePackageInfo>();
                var newVulnerabilities = new List<VulnerablePackageInfo>();

                foreach (var newVulnerablePackage in vi.BestUpdateCandidateRelatedVulnerabilities)
                {
                    foreach (var newVulnerabilty in newVulnerablePackage.Vulnerabilities)
                    {
                        if (initialVulnerabilities.ContainsKey((newVulnerablePackage.PackageName, newVulnerabilty.AdvisoryUrl)))
                        {
                            notSolvedVulnerabilities.Add(newVulnerablePackage);
                            initialVulnerabilities.Remove((newVulnerablePackage.PackageName, newVulnerabilty.AdvisoryUrl));
                        }
                        else
                            newVulnerabilities.Add(newVulnerablePackage);
                    }
                }
                vi.BestUpdateCandidateSolvedVulnerabilities.AddRange(initialVulnerabilities.Values);
                vi.BestUpdateCandidateNotSolvedVulnerabilities.AddRange(notSolvedVulnerabilities);
                vi.BestUpdateCandidateNewVulnerabilities.AddRange(newVulnerabilities);
            }
        }

        private static PackageDependencyGroup? GetBestDependencySet(IPackageSearchMetadata packageMetadata, NuGetFramework targetFramework)
        {
            var frameworkReducer = new FrameworkReducer();
            var nearestFramework = frameworkReducer.GetNearest(
                    targetFramework,
                    packageMetadata.DependencySets.Select(group => group.TargetFramework));
            if (nearestFramework == null)
                return null;
            return packageMetadata.DependencySets.First(ds => ds.TargetFramework == nearestFramework);
        }

        private static VulnerablePackageInfo[] GetVulnerabilitiesForPath(IPackageSearchMetadata packageMetadata, Dictionary<string, InstalledPackageReference> packageRefPerName, NuGetFramework targetFramework)
        { 
            var result = new HashSet<VulnerablePackageInfo>();
            if (packageMetadata.Vulnerabilities != null)
                result.Add(new VulnerablePackageInfo { PackageName = packageMetadata.Identity.Id, PackageVersion = packageMetadata.Identity.Version, Vulnerabilities = packageMetadata.Vulnerabilities.ToArray() });

            if (!packageMetadata.DependencySets.Any())
                return [.. result];

            var dependencySet = GetBestDependencySet(packageMetadata, targetFramework);
            if (dependencySet == null) // this package version is noy supported by our framework
                return null; //[.. result, new VulnerablePackageInfo()]; // TODO: dirty hack!
            foreach (var packageDependency in dependencySet.Packages) {
                if (packageRefPerName.TryGetValue(packageDependency.Id, out InstalledPackageReference? value))
                {
                    var depMethadata = value.AllPackageMetadata.Where(p => p.Identity.Version == packageDependency.VersionRange.MinVersion).FirstOrDefault(); // TODO: other version ranges?
                    if (depMethadata != null)
                        result.AddRange(GetVulnerabilitiesForPath(depMethadata, packageRefPerName, targetFramework));
                }
                // BIG TODO: we need to check new dependency for vulnerabilities!
            }
            return [.. result];
        }

        private static RealVulnerablePackageInfo CreateVulnerablePackageInfo(string packageName, NuGetVersion packageVersion, IPackageSearchMetadata packageMetadata, IEnumerable<InstalledPackageReference> references)
        {
            var result = new RealVulnerablePackageInfo()
            {
                PackageName = packageName,
                PackageVersion = packageVersion,
                Vulnerabilities = packageMetadata.Vulnerabilities.ToArray(),
                DependencyPaths = references.SelectMany(r => r.DependencyPath).ToArray()
            };
            var interestingPaths = new List<DependencyNode>();
            foreach (var dep in result.DependencyPaths) {
                var packageChildren = dep.Children.Where(c => c.Type == "package").ToHashSet();
                if (packageChildren.Count == 0)
                    continue;
                interestingPaths.Add(new DependencyNode(dep.Id, dep.Version) { Type = dep.Type, Children = packageChildren });
            }
            result.InterestingDependencyPaths = interestingPaths.ToArray();
            return result;
        }

        private static List<PackageSource> GetPackageSources(ISettings settings)
        {
            return PackageSourceProvider.LoadPackageSources(settings).Where(source => source.IsEnabled).ToList();
        }
    }
}
